<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>journal on plus7wist&#39;s blog</title>
    <link>https://plus7wist.github.io/tags/journal/</link>
    <description>Recent content in journal on plus7wist&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 25 Dec 2019 10:50:34 +0800</lastBuildDate>
    
	<atom:link href="https://plus7wist.github.io/tags/journal/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Journal 2019 12 25</title>
      <link>https://plus7wist.github.io/posts/journal-2019-12-25/</link>
      <pubDate>Wed, 25 Dec 2019 10:50:34 +0800</pubDate>
      
      <guid>https://plus7wist.github.io/posts/journal-2019-12-25/</guid>
      <description>powershell 环境变量 # 查看环境变量 ls env: # 输出环境变量 path 的值。Powershell 是大小写不敏感的 echo $env:path # 查看所有变量 ls variable: # 测试 name 变量是否存在 test-path variable:name # 测试环境变量 name 是否存在 test-path env:name haskell - ghc &amp;gt;&amp;gt;&amp;gt; pacman -S ghc ghc-static &amp;gt;&amp;gt;&amp;gt; cat hello.hs main = putStrLn &amp;quot;Hello, world&amp;quot; &amp;gt;&amp;gt;&amp;gt; ghc --make hello.hs [1 of 1] Compiling Main ( hello.hs, hello.o ) Linking hello ... &amp;gt;&amp;gt;&amp;gt; ls hello hello.hi hello.hs hello.o &amp;gt;&amp;gt;&amp;gt; ./hello Hello, world haskell - IO action ghci&amp;gt; :t getLine getLine :: IO String getLine 返回一个得到 String 的 IO action。用 name &amp;lt;- getLine 解开这个包，而 name = getLine，使得 name 获取了这个 IO action。</description>
    </item>
    
    <item>
      <title>Journal 2019 12 19</title>
      <link>https://plus7wist.github.io/posts/journal-2019-12-19/</link>
      <pubDate>Thu, 19 Dec 2019 10:50:34 +0800</pubDate>
      
      <guid>https://plus7wist.github.io/posts/journal-2019-12-19/</guid>
      <description>Ruby - Struct CliConf = Struct.new(:task, :tee) CliError = Struct.new(:error) conf = CliConf.new(:command, false) error = CliError.new(&amp;#39;Empty: empty task&amp;#39;) Struct 还能跟一个代码块，可以在里面加方法。
Ruby - is_a? instance_of? Ruby 的对象有继承关系，例如字符串都是 String 类，String 类继承自 Object 类。所以，一个字符串是一个（is_a?）String，也是一个（is_a?） Object。又可以说一个字符串是 String 的实例（instance_of?），但是不是 Object 的实例。
还有 kind_of?，跟 is_a? 是同一个意思。
Ruby - rubocop 和 rofo 我本來以爲 rubocop 只是個靜態檢查工具，但是今天看了看，其實也是個格式化工具。 rufo 單獨是個格式化工具，而且它的方向傾向於變成一個 opinionated（固執己見的）格式化工具，也就是說越加不能配置格式化的結果。詳情見：https://github.com/ruby-formatter/rufo/issues/2。
rubocop 有個 -a 選項，可以自動修改一些簡單的格式，這也是它作爲一個格式化工具的方法。
Ruby - 切片 Ruby 數組的切片有兩種語法：a[start..end] 和 a[start...end]。區別在於前一種包括最後一個，後一種不包括。我不喜歡這種做法，因爲長得太像，實在記不住。
還有省略內容 a[start..]，表示從 start 開始到末尾。但是這種語法好像是被遺棄了，現在的做法是 a[start..-1]。
Graphviz 複習一下簡單的用法：</description>
    </item>
    
    <item>
      <title>Journal 2019 12 17</title>
      <link>https://plus7wist.github.io/posts/journal-2019-12-17/</link>
      <pubDate>Tue, 17 Dec 2019 10:50:34 +0800</pubDate>
      
      <guid>https://plus7wist.github.io/posts/journal-2019-12-17/</guid>
      <description>Rufo Ruby 的代码格式化工具。应该是 Ruby Formatter 的简称。
gem install rufo rufo &amp;lt;file&amp;gt; rufo &amp;lt;dir&amp;gt; Rubocop Ruby 代码的风格检查工具。
gem install rubocop rubocop rubocop &amp;lt;file&amp;gt; rubocop &amp;lt;dir&amp;gt; config-rs https://github.com/mehcode/config-rs
Rust 配置文件解读工具。很多时候需要多层的配置结合起来，而且为不同的字段设计默认值。只用某种结构化数据格式要完成完整的配置需要还是需要很多工作的。
impl Settings { pub fn new() -&amp;gt; Result&amp;lt;Self, ConfigError&amp;gt; { let mut s = Config::new(); s.merge(File::with_name(&amp;#34;config/default&amp;#34;))?; s.merge(Environment::with_prefix(&amp;#34;app&amp;#34;))?; s.set(&amp;#34;database.url&amp;#34;, &amp;#34;postgres://&amp;#34;)?; s.try_into() } } Ruby - Open3 require &amp;#39;open3&amp;#39; def run_cmd(cmds) Open3.popen2(*cmds) { |stdin_pipe, stdout_pipe| // } Open3.open2e(*cmds) { |stdin_pipe, stdouterr_pipe| // } Open3.open3(*cmds) { |stdin_pipe, stdout_pipe, stderr_pipe| // } end ShellCheck pacman -S shellcheck shellcheck &amp;lt;script.</description>
    </item>
    
  </channel>
</rss>