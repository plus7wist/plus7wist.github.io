---
title: "Rust 语言编程概要"
date: 2020-09-07T19:24:52+08:00
draft: true
---

学习了一段时间 Rust 之后，受同事启发做此文章。是对自我认识的复盘和梳理，如果同时能给人以启发，那就是额外的惊喜了。

这篇文章假设读者有一定的 C++ 编程能力，这样便不必从语言定义讲起而显得冗长。

## Rust 是什么

Rust 是一门新兴的编程语言，目的方向是系统编程，但因为良好的设计和工具链，它的用处正在不断扩展。

它被设计成有零开销抽象能力，所以运行时不那么厚实，没有动态内存回收的能力，也没有异步支持。但它的语法扩展性很强，所以可以在语言定义外实现异步运行时，甚至可能实现垃圾回收器（但没有人会这样做罢了）。日前的 Rust 异步已经大放异彩，正是使用这种思路。

它的类型系统是通用编程语言里较强的，这也是它竞争力的一部分。Rust 选择的是代数数据类型系统，而且很难在类型系统里找到窟窿。

Rust 还有宏编程和模板编程，这让它具有很强的表现力。而相比 C++ 的宏和模板，Rust 的这些设施更为现代化，更为安全、可控。

目前最流行 Rust 编译器是 rustc，它以 llvm 为后端，将 Rust 代码编译成机器代码或者中间代码。cargo 是 rustc 的包管理器和包构建工具，rustup 是 rustc 的工具链管理工具。一个典型的 Rust 程序开发过程中，使用 rustup 管理不同版本和不同目标的 cargo 和 rustc，使用 cargo 创建包，管理包，调用 rustc 编译包，少有直接调用 rustc 的情况。

但 Rust 最突出的特点，还是它的借用检查器。借用很像 C++ 的引用，但它因为严格的借用策略而精彩。因为借用检查器的特殊策略，Rust 能提供一些特别的保证：Rust 代码是内存安全的；Rust 的并发代码没有数据竞争。只有在天上能找到的保证来到了地上。

以上的保证有其例外，这就是 unsafe 代码，unsafe 代码是由编程者负责软件内存安全和并发安全的代码。正确书写 unsafe 代码十分困难：主要归因于社区开发惯例认为 unsafe 代码不能破坏任何非 unsafe 代码的安全性。也就是说，unsafe 代码是作者不能假定非 unsafe 代码的使用方式，反之就认为这段代码是错误的。故意使用错误 unsafe 代码的行为定义可以被社区定义为恶意行为。

也因为借用检查器的严格规则，Rust 编程有其比较陡峭的入门曲线。程序作者写的任何有借用风险的代码都无法通过编译，甚至有时需要手动标注变量的生命周期。这可能是一部分人讨厌和轻视 Rust 的原因。但总的来说，这些过程会使得程序作者变得更强大，所以我个人尚可以欣然接受这些硬核的部分，也希望阅读这篇文章的读者能够接受它们。

## 你好，世界

假设你已经用 rustup 安装了 cargo，或者用其他的方式安装了 cargo 使它正确运行。接下来就是创建一个新的包试一试：

    cargo init hello
    cd hello
    cargo run

以上命令创建了一个 hello 文件夹，这个文件夹里的内容就是一个“包”。这个运行过程应该打印一行 Hello, world! 到标准输出。

## 函数

上述由 cargo 生成的代码可能是这样：

  ```rust
  fn main() {
      println!("Hello, world!");
  }
  ```

只需要指出两点：

1. fn 是定义函数的标志。与 C 不一样，定义函数和定义变量语法不同。
2. println! 不是函数而是**宏**。以感叹号结尾，看起来像函数的就是宏。

我们也可以用标准库的函数来完成这个任务：

  ```rust
  use std::io::Write;

  fn main() {
      let _ = std::io::stdout().write(b"Hello, world!");
  }
  ```

1. 与 C++ 名字空间类似的语法让 C++ 伙伴们倍感亲切。但这个系统更强大和安全，所以它名叫**模块**，引入的过程名叫**路径**。
2. let 是定义变量的标准，这样变量和函数的定义语法就完全不一样了。
3. write 函数的返回值赋值给了下划线变量（_）。
