# Golang 并发有关的语义

这是参考 <https://docs.studygolang.com/ref/spec>，学习 golang 的并发有关语义的笔记。

## 前言

我不想建立 Golang 黑粉的形象，但是客观的说，Golang 是我遇到的最难学的语言之一。

## 通道

通道是一类控制 Goroutine（简称 GR）之间通信的类型的统称。它有三个维度的参数：

1. 类型：`chan T` 是指通道中数据的类型是 `T`，这个通道基本上需要用来在 GR 之间交换 `T` 类型。

2. 方向：`<-chan T` 是指通道只能收数据，`chan<- T` 是指通道只能发数据，`chan T` 则两者都可以。

3. 值：

   1. 空通道：不初始化的通道。

   1. 缓冲通道：用 make 初始化，而且长度参数不是 0 的。

   1. 不缓冲通道：用 make 初始化，但长度参数是 0 或没有长度参数的：

          make(chan SomeType, 0)
          make(chan SomeType)

一个通道的行为可以从如下一些维度来描述：

1. 收发类型：收发数据的类型。
2. 收发方向。
3. 收发时阻塞情况。
4. 关闭表现。

前两者分别由通道类型和通道方向决定，语义比较简单，不再赘述。

### 关闭

关闭表现受值影响，并且定义成只能关闭发送通道。

1. 当通道是收信通道，在其上应用 `close` 函数会产生编译错误，Golang 拒绝了这部分代码。

2. 关闭只发送的通道的语义是比较清楚的。发送端之后不能自己再次关闭此通道，或者关闭后向通道发信。这表示当前 GR 多是唯一的生产者。如果不然，大概需要 `sync.WaitGroup` 来等待所有生产者退出。

3. 关闭收发通道的语义则有些复杂。一个 GR 是发信端时，关闭的行为跟它是只发送的通道时一样；GR 是收信端，且能够拿到收发队列，那么就能自己关闭发通道，也就是意味着从语义上关闭了接收通道，但这种做法需要接受发送者会恐慌致死的结果。所以若非处理了恐慌，或者保证关闭通道之前通过信号制止发信端发信，不应该关闭收信端。不然会因为恐慌的传染导致所有的 GR 恐慌。

所以我的思路大概是：关闭发信通道。

### 空通道

空通道是一种永远阻塞的通道，向通道发送数据或者从空通道取出数据的语句永远不会返回，关闭空通道时会触发恐慌。所以大概率不会有使用空通道的场景。

### 缓冲通道

缓冲通道维护一个定长的缓冲区。缓冲区满的时候会阻塞发送一端的发送语句，缓冲区空的时候会阻塞接收一端的接收语句。接收一端接收数据会消费掉通道缓冲区中的数据。

通道关闭后，再向通道写入数据会触发恐慌。

因为缓冲的存在，通道关闭时通道中可能还有剩余信息。这些信息还能被接收端读取到，但是当然不会阻塞了。直到接收方把数据都消费掉，通道就进入了关闭且空的状态。

当通道关闭且空，接收语句可以不阻塞的接收到通道类型的零值。用多返回值的接收语句可以判断出这种情况。反过来说，如果要使用单返回值的接收语句，那就得保证程序在被无数零值轰炸的时候也能正确表现，或者能保证通道永远不会关闭。这些都不是什么好思路。

### 不缓冲通道

不缓冲通道则更像是任意门，只有收发都准备好了，才会进行发送动作，否则另一端就要等待。它的其他表现与缓冲通道是相同的。

不缓冲通道看起来不是有缓冲区但是缓冲区长度是 0 的通道。按照缓冲通道的定义，如果缓冲区长度是 0，那么发送方发送过程永远阻塞，接收方接收过程也永远阻塞。除了可以关闭，这更像是对空通道的描述。

不缓冲通道更接近有缓冲区但是缓冲区长度是 1 的通道。读者和写者基本上是速度同步的。区别在于，后者读写不会同时发生，后者总是从写开始。

## 使用通道的思路

按照上面的讨论，有几点实践。

- 不要使用空通道，即永远用 `make` 构建通道。
- 记得防止通道出现重复关闭问题。
- 牢记不同通道的通信模型。
- 在需要关闭的通道接收数据时总是使用二值接收，防止收到零值。

## select 语句

select 语句的语义也十分复杂。需要进行一些概括和举例。

select 没有循环语义，所以每个表达式至多求值一次。它需要检查所有收发通道，所以一定要求值收发语句的通道一端。但在可能不发生发送的前提下也非要求值被发送的数据。也就是说，select 会求值整个发送任务的左右两端，但不完全求值接收任务的接收一端。

当有多个通道都是不阻塞的状态，select 不是顺序而是随机选择收发任务。被选择的任务如果是接收任务，那么它的接收端会被求值，相应的其他接受端不会被求值。执行完了选中的任务之后再执行此任务对应分支下的代码。

default 分支影响所有收发任务都阻塞时的表现。如果有 default，那么跳入 default 分支执行代码；如果没有则在 select 处等待。

## select 语义举例

随机 0-1 串发入通道 c：

    select {
    case c <- 0:
    case c <- 1:
    }

永远阻塞：

    select {}

同步执行代码：

    select {
    default:
            JustDoIt()
    }

等待最先到达的消息：

    select {
    case m1 := <-c1:
            OnMessage(m1, c1)
    case m2 := <-c2:
            OnMessage(m2, c2)
    }

检查是否有消息：

    select {
    case m := <-c:
            OnMessage(m, c)
    default:
            OnNoMesssage(c)
    }

超时等待消息：

    select {
    case m := <-c:
            OnMessage(m, c)
    case time.After(timeout):
            OnTimeout(c)
    }

上面多举例了接收模式，发送模式也是类似的。

## select 的思路

也可以总结出一些思路：

- 不要将有副作用或者有大量计算的函数调用放在 select 选择分支里。
  - 可能搞不懂它会不会求值。
  - 可能搞得懂，但是看不明白。
- select 的语义是对 golang 类型和函数泛化能力的补充。要把它视作编程接口。

## go 语句

go 语句用于创建一个 GR，它的格式钉死在函数调用上：

    go Server(x, y, z)
    go object.Method(a, b, c)
    go func(c chan<- int) { for { sleep(10); c <- 1 } } (c)

go 语句不会创建对 GR 进行管理的句柄，使用者需要自己实现。输入、输出和终止都需要通过通道实现。这里的思路就是要不断熟悉这些控制逻辑：因为不太有办法复用别人的实现。也常见用输入通道的关闭代表终止命令。下面列举了数据流处理过程中的节点：

    func DataSource(stop <-chan bool, output chan<- int) {
            defer close(output)
            for i := 0; true; i++ {
                    select {
                    case <-stop:
                            break
                    case <-time.After(DurationSecond(1)):
                            output <- i
                    }
            }
    }

    func DataFilter(input <-chan int, output chan<- int) {
            defer close(output)
            for {
                    data, ok := <-input
                    if !ok {
                            break
                    }
                    output <- data * 10
            }
    }

    func DataTarget(input <-chan int) {
            for {
                    data, ok := <-input
                    if !ok {
                            break
                    }
                    fmt.Println("target data", data)
            }
    }

但是正如在关闭问题上提出的，这些关闭都独占了通道。多数场景都不能这样做。
