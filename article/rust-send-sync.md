# Rust 的数据竞争规则和线程安全

Rust 是一门新兴编程语言，以无开销的安全性著称。Rust 语言的入门门槛较高，相对而言，熟悉 Rust 的程序员大多对它留有深刻的印象。当他们遇到各类数据竞争导致的缺陷时，多半会着魔一样说「如果用 Rust 就不会有这种问题了」。但对不熟悉 Rust 的人来说，Rust 的力量显得更像空中楼阁，在多次与 Rust 编译器搏斗之后，他们往往会喃喃「有必要吗？」，然后放弃 Rust。但我相信，这都是误解导致的不良体验，因此可能需要一些对不了解 Rust 的同志推销 Rust 在数据竞争方面的核心思路的研讨。即使他们最终不能变成 Rust 的拥趸，也可能在他们自己的领域里将 Rust 的精神发扬光大。

本文拟介绍 Rust 的数据竞争规则，并解释 Rust 的线程安全保证，不需要读者会使用 Rust 语言编程，但需要读者理解至少一门通用编程语言，而且理解并发编程的基础。

## 数据的抽象

任何程序都是对数据和对数据的读写完成的。为了对读写进行抽象，许多编程语言都引入了「指针」或「引用」这类概念。有个典型的好处是，当两个模块都要使用同一项 1MB 的数据，他们只需要每一方持有一个 4B 的引用，而不必每一方都持有 1MB，这样就相当于节省了接近 50% 的空间。但是同时带来的问题是，当一方因为自己的需求修改了这 1MB 的数据中的一部分，另一方如果不对此数据作出响应，或者不期待发生这种改变，那多半会造成缺陷。举例说明：

> 对数据和动作的抽象是所有编程模型都必须完成的任务。典型的命令式编程。
